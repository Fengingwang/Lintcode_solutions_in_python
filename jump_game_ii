# The basic thoughts underline is a greedy style
# Every one more jump, you want to jump as far as possible
# In Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position
# In Jump Game II, you care about what would be the next furthest jump could be made 
#                  when you could reach as far as ith position from last jump
#                  So you iterate all positions could be reached from last jump till ith position to find it out

# DP
class Solution:
    def jump(self, A):
        # write your code here
        if A is None or len(A) == 0: return 
        
        n = len(A)
        f = [sys.maxsize for _ in range(n)]
        f[0] = 0
        
        for i in range(0, n - 1):
            for j in range(A[i], 0, -1):
                if i + j < n:
                    if f[i + j] > 1 + f[i]:
                        f[i + j] = 1 + f[i]
                    else:
                        break 
        
        return f[-1]

# Greedy 
class Solution:
    """
    @param A: A list of integers
    @return: An integer
    """
    def jump(self, A):
        # write your code here
        last, curt, step, i = 0, 0, 0, 0
        while curt < len(A) - 1:
            while i <= last:
                curt = max(i + A[i], curt)
                i += 1
            if last == curt:
                return -1
            last = curt 
            step += 1
        return step 
        
