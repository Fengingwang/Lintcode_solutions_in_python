http://liadbiz.github.io/leetcode-single-number-problems-summary/

# XOR3
# a XOR3 a XOR3 a = 0
# a XOR3 0 = a
# 交换律
# 结合律

# 3_bit only 0 1 2 will show up
# 0 1 2
# 0 1 2
# 0 1 2 
# -----
# 0 0 0
# 抵销思想

# 用一个32位的数的每一位表示某一位出现几次，出现3次就给它归零
# 如果除一个数字外其余的数字出现了n次
# 可以用了一个包含32个元素（因为int型数值为32位）的数组来记录每一个位出现的次数，
# 最后对每位对n进行取余操作(出现3次就给它归零), 并通过位移操作将剩余的数字拼起来。

class Solution:
    """
    @param A: An integer array
    @return: An integer
    """
    def singleNumberII(self, A):
        # write your code here
        if A is None or len(A) == 0:
            return - 1
        
        res = 0
        for i in range(32):
            temp = 0
            for num in A:
                if (num >> i & 1) == 1:
                    temp += 1
                    temp = temp % 3
                    
            res |= temp << i
        
        return res



# &	按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0	(a & b) 输出结果 12 ，二进制解释： 0000 1100
# |	按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。	(a | b) 输出结果 61 ，二进制解释： 0011 1101
# ^	按位异或运算符：当两对应的二进位相异时，结果为1	(a ^ b) 输出结果 49 ，二进制解释： 0011 0001
# ~	按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1	(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。
# <<	左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。	a << 2 输出结果 240 ，二进制解释： 1111 0000
# >>	右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数	a >> 2 输出结果 15 ，二进制解释： 0000 1111

# a = 60            # 60 = 0011 1100 
# b = 13            # 13 = 0000 1101 
# c = 0
# c = a & b;        # 12 = 0000 1100
# c = a | b;        # 61 = 0011 1101 
# c = a ^ b;        # 49 = 0011 0001
# c = ~a;           # -61 = 1100 0011
# c = a << 2;       # 240 = 1111 0000
# c = a >> 2;       # 15 = 0000 1111
