BST中找中序遍历的后继节点
class Solution:
    def inorderSuccessor(self, root, p):
        # write your code here
        if not root or not p: return 
        
        res = TreeNode(None)
        while root: 
            if root.val > p.val: 
                res = root
                root = root.left
            else: 
                root = root.right 
        
        if res.val == None: return 
        else: return res
        
class Solution:
    def inorderSuccessor(self, root, p):
        # write your code here
        if root is None or p is None:
            return 
        if root.val <= p.val:
            return self.inorderSuccessor(root.right, p)
        else:
            left = self.inorderSuccessor(root.left, p)
            if left is None:
                return root 
            else:
                return left
                
# 方法充分地利用到了BST的性质，
# 我们首先看根节点值和p节点值的大小，
# 如果根节点值大，说明p节点肯定在左子树中，
# 那么此时我们先将res赋为root，然后root移到其左子节点，
# 循环的条件是root存在，
# 我们再比较此时root值和p节点值的大小，如果还是root值大，我们重复上面的操作，
# 如果p节点值，那么我们将root移到其右子节点，
# 这样当root为空时，res指向的就是p的后继节点

class Solution:
    """
    @param: root: The root of the BST.
    @param: p: You need find the successor node of p.
    @return: Successor of p.
    """
    def inorderSuccessor(self, root, p):
        # write your code here
        if not root or not p: return 
        self.pre, self.suc = TreeNode(None), TreeNode(None)
        self.search(root, p)
        if self.suc.val == None: return 
        else: return self.suc       
        
    def search(self, root, p):
        if not root: return 
        self.search(root.left, p)
        if p == self.pre: self.suc = root 
        self.pre = root
        self.search(root.right, p)
        

            
